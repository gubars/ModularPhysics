/-
Copyright (c) 2025 ModularPhysics. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import ModularPhysics.RigorousQFT.SPDE.Basic
import Mathlib.Probability.Independence.Basic

/-!
# Brownian Motion and Wiener Processes

This file defines Brownian motion, cylindrical Wiener processes,
and related constructions for SPDEs.

## Main Definitions

* `BrownianMotion` - Standard Brownian motion / Wiener process
* `CylindricalWienerProcess` - Cylindrical Wiener process on a Hilbert space
* `QWienerProcess` - Q-Wiener process with covariance operator Q

## Mathematical Properties

A standard Brownian motion W_t is characterized by:
1. W_0 = 0 a.s.
2. Continuous sample paths a.s.
3. Independent increments: W_t - W_s is independent of F_s for s ≤ t
4. Gaussian increments: W_t - W_s ~ N(0, t-s) for s ≤ t

## References

* Karatzas, Shreve, "Brownian Motion and Stochastic Calculus"
* Da Prato, Zabczyk, "Stochastic Equations in Infinite Dimensions"
-/

namespace SPDE

open MeasureTheory ProbabilityTheory

variable {Ω : Type*} [MeasurableSpace Ω]

/-! ## Gaussian Distribution Characterization -/

/-- A random variable X : Ω → ℝ has Gaussian distribution N(μ, σ²).
    Characterized by the characteristic function: E[e^{itX}] = e^{itμ - σ²t²/2}. -/
structure IsGaussian (μ : Measure Ω) (X : Ω → ℝ) (mean : ℝ) (variance : ℝ) : Prop where
  /-- Variance is non-negative -/
  variance_nonneg : variance ≥ 0
  /-- The random variable is integrable -/
  integrable : Integrable X μ
  /-- Mean equals the expected value -/
  mean_eq : ∫ ω, X ω ∂μ = mean
  /-- Second moment gives the variance -/
  variance_eq : ∫ ω, (X ω - mean)^2 ∂μ = variance
  /-- Characteristic function characterization (implies Gaussianity) -/
  char_function : ∀ t : ℝ,
    ∫ ω, Complex.exp (Complex.I * t * X ω) ∂μ =
      Complex.exp (Complex.I * t * mean - variance * t^2 / 2)

/-! ## Brownian Motion -/

/-- Standard Brownian motion (Wiener process).

    A process W : [0, ∞) × Ω → ℝ satisfying:
    1. W_0 = 0 a.s.
    2. Continuous sample paths a.s.
    3. Independent increments: for 0 ≤ s < t, the increment W_t - W_s is
       independent of the σ-algebra F_s = σ(W_u : u ≤ s)
    4. Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t

    These four properties uniquely characterize Brownian motion (in distribution).
    Note: Stationarity follows from (4): the distribution of W_t - W_s depends
    only on t - s, not on s or t individually. -/
structure BrownianMotion (Ω : Type*) [MeasurableSpace Ω] (μ : Measure Ω) where
  /-- The underlying filtration (natural filtration of W) -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F ℝ
  /-- Initial condition: W_0 = 0 a.s. -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths a.s. -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)

  /-- Independent increments: W_t - W_s is independent of F_s for s ≤ t.
      Expressed as: the σ-algebra generated by the increment is independent
      of F_s in the sense of Mathlib's `Indep`. -/
  independent_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    Indep (F.σ_algebra s) (MeasurableSpace.comap (fun ω => toAdapted.process t ω - toAdapted.process s ω) inferInstance) μ

  /-- Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t.
      This implies both zero mean and variance = t - s. -/
  gaussian_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    IsGaussian μ (fun ω => toAdapted.process t ω - toAdapted.process s ω) 0 (t - s)

/-- Alternative characterization using the product measure formulation of independence:
    For disjoint intervals, the increments are independent. -/
def BrownianMotion.disjoint_independent {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) :
    ∀ s₁ t₁ s₂ t₂ : ℝ, 0 ≤ s₁ → s₁ ≤ t₁ → t₁ ≤ s₂ → s₂ ≤ t₂ →
    IndepFun (fun ω => W.toAdapted.process t₁ ω - W.toAdapted.process s₁ ω)
             (fun ω => W.toAdapted.process t₂ ω - W.toAdapted.process s₂ ω) μ := by
  intro s₁ t₁ s₂ t₂ hs₁ ht₁ hs₂ ht₂
  -- The second increment is independent of F_{s₂} ⊇ F_{t₁} ⊇ σ(first increment)
  sorry

/-- Stationary increments: W_{t+h} - W_t has the same distribution as W_h - W_0 = W_h.
    This follows from the Gaussian characterization. -/
theorem BrownianMotion.stationary_increments {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) :
    ∀ s t : ℝ, 0 ≤ s → 0 ≤ t →
    Measure.map (fun ω => W.toAdapted.process (s + t) ω - W.toAdapted.process s ω) μ =
    Measure.map (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ := by
  intro s t hs ht
  -- Both increments are N(0, t) by gaussian_increments, so they have the same distribution
  sorry

/-- Zero mean of increments (follows from Gaussian with mean 0) -/
theorem BrownianMotion.increment_mean_zero {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω) ∂μ = 0 :=
  (W.gaussian_increments s t hs hst).mean_eq

/-- Variance of increments (follows from Gaussian with variance t-s) -/
theorem BrownianMotion.increment_variance {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω)^2 ∂μ = t - s := by
  have h := (W.gaussian_increments s t hs hst).variance_eq
  simp only [sub_zero] at h
  exact h

namespace BrownianMotion

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}

/-- The process underlying Brownian motion -/
def process (W : BrownianMotion Ω μ) : ℝ → Ω → ℝ := W.toAdapted.process

/-- Brownian motion is a martingale -/
theorem is_martingale (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∃ M : Martingale W.F μ ℝ, M.process = W.process := by
  sorry

/-- The quadratic variation of Brownian motion is t -/
theorem quadratic_variation (W : BrownianMotion Ω μ) :
    ∃ qv : QuadraticVariation W.F,
      qv.process = W.process ∧
      (∀ t : ℝ, ∀ᵐ ω ∂μ, qv.variation t ω = t) := by
  sorry

/-- Brownian scaling: if W_t is a BM, then c^{-1/2} W_{ct} is also a BM -/
theorem scaling (W : BrownianMotion Ω μ) (c : ℝ) (hc : 0 < c) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = c^(-(1/2 : ℝ)) * W.process (c * t) ω := by
  sorry

/-- Reflection principle: -W is also a Brownian motion -/
theorem reflection (W : BrownianMotion Ω μ) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = -W.process t ω := by
  sorry

/-- Time inversion: tW_{1/t} is a Brownian motion (for t > 0) -/
theorem time_inversion (W : BrownianMotion Ω μ) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, 0 < t → ∀ᵐ ω ∂μ, W'.process t ω = t * W.process (1/t) ω := by
  sorry

end BrownianMotion

/-! ## Multidimensional Brownian Motion -/

/-- d-dimensional Brownian motion -/
structure BrownianMotionD (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (Fin d → ℝ)
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)
  /-- Covariance: E[W_t^i W_s^j] = (t ∧ s) δ_{ij} -/
  covariance : ∀ i j : Fin d, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω i) * (toAdapted.process s ω j) ∂μ =
      if i = j then min t s else 0

/-! ## Cylindrical Wiener Process -/

/-- A cylindrical Wiener process on a Hilbert space H.
    This is a generalization of Brownian motion to infinite dimensions. -/
structure CylindricalWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [MeasurableSpace (H →L[ℝ] ℝ)] where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (H →L[ℝ] ℝ)
  /-- Isometry property: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨h₁, h₂⟩ -/
  isometry : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω h₁) * (toAdapted.process s ω h₂) ∂μ =
      min t s * @inner ℝ H _ h₁ h₂

namespace CylindricalWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [MeasurableSpace (H →L[ℝ] ℝ)]

/-- The cylindrical Wiener process evaluated on h ∈ H gives a real-valued process -/
def eval (W : CylindricalWienerProcess Ω μ H) (h : H) : ℝ → Ω → ℝ :=
  fun t ω => W.toAdapted.process t ω h

/-- Evaluation on a unit vector gives a standard Brownian motion -/
theorem eval_unit_is_brownian (W : CylindricalWienerProcess Ω μ H) (h : H) (hh : ‖h‖ = 1) :
    ∃ B : BrownianMotion Ω μ, ∀ t : ℝ, ∀ᵐ ω ∂μ, B.process t ω = W.eval h t ω := by
  sorry

end CylindricalWienerProcess

/-! ## Q-Wiener Process -/

/-- A trace-class operator on a separable Hilbert space H.

    A bounded linear operator Q : H → H is trace-class if:
    1. Q is self-adjoint: ⟨Qx, y⟩ = ⟨x, Qy⟩
    2. Q is non-negative: ⟨Qx, x⟩ ≥ 0
    3. The trace Tr(Q) = Σᵢ ⟨Qeᵢ, eᵢ⟩ is finite for any ONB {eᵢ}

    For such operators, there exists an orthonormal basis of eigenvectors
    with non-negative eigenvalues λᵢ such that Σᵢ λᵢ < ∞. -/
structure TraceClassOperator (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] where
  /-- The underlying continuous linear map -/
  toLinearMap : H →L[ℝ] H
  /-- Self-adjoint: ⟨Qh₁, h₂⟩ = ⟨h₁, Qh₂⟩ -/
  self_adjoint : ∀ h₁ h₂ : H, @inner ℝ H _ (toLinearMap h₁) h₂ = @inner ℝ H _ h₁ (toLinearMap h₂)
  /-- Non-negative: ⟨Qh, h⟩ ≥ 0 -/
  nonneg : ∀ h : H, @inner ℝ H _ (toLinearMap h) h ≥ 0
  /-- Trace is finite: Σᵢ ⟨Qeᵢ, eᵢ⟩ < ∞ for any orthonormal basis {eᵢ}.
      We express this via the eigenvalue characterization:
      there exist eigenvalues λᵢ ≥ 0 with Σᵢ λᵢ < ∞. -/
  eigenvalues : ℕ → ℝ
  eigenvalues_nonneg : ∀ i, eigenvalues i ≥ 0
  eigenvalues_summable : Summable eigenvalues

/-- The trace is the sum of eigenvalues -/
noncomputable def TraceClassOperator.trace {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] (Q : TraceClassOperator H) : ℝ := ∑' i, Q.eigenvalues i

namespace TraceClassOperator

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H]

/-- The trace is non-negative -/
theorem trace_nonneg (Q : TraceClassOperator H) : Q.trace ≥ 0 := by
  apply tsum_nonneg
  exact Q.eigenvalues_nonneg

/-- Zero operator is trace-class with trace 0 -/
def zero : TraceClassOperator H where
  toLinearMap := 0
  self_adjoint := fun _ _ => by simp
  nonneg := fun _ => by simp
  eigenvalues := fun _ => 0
  eigenvalues_nonneg := fun _ => le_refl 0
  eigenvalues_summable := summable_zero

end TraceClassOperator

/-- A Q-Wiener process with covariance operator Q.
    More regular than cylindrical Wiener process when Tr(Q) < ∞. -/
structure QWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] [MeasurableSpace H] (Q : TraceClassOperator H) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F H
  /-- Covariance: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨Qh₁, h₂⟩ -/
  covariance : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, @inner ℝ H _ (toAdapted.process t ω) h₁ * @inner ℝ H _ (toAdapted.process s ω) h₂ ∂μ =
      min t s * @inner ℝ H _ (Q.toLinearMap h₁) h₂

namespace QWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H] [MeasurableSpace H]
variable {Q : TraceClassOperator H}

/-- Q-Wiener process has continuous paths in H -/
theorem continuous_paths (W : QWienerProcess Ω μ H Q) :
    ∀ᵐ ω ∂μ, Continuous (fun t => W.toAdapted.process t ω) := by
  sorry

/-- The covariance operator determines the regularity -/
theorem regularity_from_trace (W : QWienerProcess Ω μ H Q) :
    ∀ t : ℝ, 0 ≤ t → ∃ (bound : ℝ), ∫ ω, ‖W.toAdapted.process t ω‖^2 ∂μ ≤ bound := by
  sorry

end QWienerProcess

/-! ## Space-Time White Noise -/

/-- Space-time white noise on a domain D ⊆ ℝ^d -/
structure SpaceTimeWhiteNoise (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) (D : Set (Fin d → ℝ)) [MeasurableSpace D] (ν : Measure D) where
  /-- The distribution W(ϕ) for test function ϕ -/
  eval : (D → ℝ) → (Ω → ℝ)
  /-- Linearity -/
  linear : ∀ a b : ℝ, ∀ ϕ ψ : D → ℝ,
    eval (fun x => a * ϕ x + b * ψ x) = fun ω => a * eval ϕ ω + b * eval ψ ω
  /-- Isometry: E[W(ϕ)W(ψ)] = ⟨ϕ, ψ⟩_{L²} -/
  isometry : ∀ ϕ ψ : D → ℝ, ∫ ω, eval ϕ ω * eval ψ ω ∂μ = ∫ x, ϕ x * ψ x ∂ν

/-! ## Lévy's Characterization -/

/-- Lévy's characterization: a continuous local martingale with
    quadratic variation ⟨M⟩_t = t is a Brownian motion. -/
theorem levy_characterization {Ω : Type*} [MeasurableSpace Ω]
    {F : Filtration Ω ℝ} {μ : Measure Ω} [IsProbabilityMeasure μ]
    (M : LocalMartingale F μ ℝ)
    (continuous : ∀ᵐ ω ∂μ, Continuous (fun t => M.process t ω))
    (initial : ∀ᵐ ω ∂μ, M.process 0 ω = 0)
    (qv : QuadraticVariation F)
    (hqv_process : qv.process = M.process)
    (hqv_is_t : ∀ t : ℝ, 0 ≤ t → ∀ᵐ ω ∂μ, qv.variation t ω = t) :
    ∃ W : BrownianMotion Ω μ, W.process = M.process := by
  sorry

/-! ## Brownian Bridge -/

/-- Brownian bridge from 0 to a at time T -/
structure BrownianBridge (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (T : ℝ) (hT : 0 < T) (a : ℝ) where
  /-- The process on [0, T] -/
  process : Set.Icc 0 T → Ω → ℝ
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, process ⟨0, by constructor <;> linarith⟩ ω = 0
  /-- Terminal condition -/
  terminal : ∀ᵐ ω ∂μ, process ⟨T, by constructor <;> linarith⟩ ω = a
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => process t ω)
  /-- Covariance: E[B_s B_t] = s(T-t)/T for s ≤ t -/
  covariance : ∀ (s t : Set.Icc 0 T), s.val ≤ t.val →
    ∫ ω, process s ω * process t ω ∂μ = s.val * (T - t.val) / T

/-! ## Ornstein-Uhlenbeck Process -/

/-- Ornstein-Uhlenbeck process: dX_t = -θ X_t dt + σ dW_t

    The explicit solution is:
    X_t = X_0 e^{-θt} + σ ∫₀ᵗ e^{-θ(t-s)} dW_s

    Key properties:
    1. Conditional mean: E[X_t | X_0] = X_0 e^{-θt}  (mean-reversion)
    2. Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt})
    3. Stationary distribution: N(0, σ²/2θ)
    4. Gaussian process (all finite-dimensional distributions are Gaussian) -/
structure OrnsteinUhlenbeck (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (θ σ : ℝ) (hθ : 0 < θ) (hσ : 0 < σ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The process -/
  process : ℝ → Ω → ℝ
  /-- Driven by Brownian motion -/
  driving_BM : BrownianMotion Ω μ
  /-- Adapted to the filtration -/
  adapted : ∀ t : ℝ, @Measurable Ω ℝ (F.σ_algebra t) _ (process t)
  /-- Mean-reverting property: E[X_t | F_0] = X_0 e^{-θt}
      Expressed via conditional expectation: for all F_0-measurable sets A,
      ∫_A X_t dμ = ∫_A X_0 e^{-θt} dμ -/
  mean_reversion : ∀ t : ℝ, 0 ≤ t →
    ∀ A : Set Ω, @MeasurableSet Ω (F.σ_algebra 0) A →
    ∫ ω in A, process t ω ∂μ = ∫ ω in A, process 0 ω * Real.exp (-θ * t) ∂μ
  /-- Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt})
      The unconditional variance of the centered process equals this value. -/
  conditional_variance : ∀ t : ℝ, 0 ≤ t →
    ∫ ω, (process t ω - process 0 ω * Real.exp (-θ * t))^2 ∂μ =
      (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))
  /-- X_t is Gaussian given X_0 -/
  gaussian_conditional : ∀ t : ℝ, 0 ≤ t →
    IsGaussian μ (fun ω => process t ω - process 0 ω * Real.exp (-θ * t))
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))

/-- In the stationary regime (t → ∞), Var(X_t) → σ²/(2θ) -/
theorem ou_stationary_variance {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) :
    Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds (σ^2 / (2 * θ))) := by
  have h : Filter.Tendsto (fun t => Real.exp (-2 * θ * t)) Filter.atTop (nhds 0) := by
    have hcoef : -2 * θ < 0 := by linarith
    have hmul : Filter.Tendsto (fun t => -2 * θ * t) Filter.atTop Filter.atBot :=
      (Filter.tendsto_const_mul_atBot_of_neg hcoef).mpr Filter.tendsto_id
    exact Real.tendsto_exp_atBot.comp hmul
  have h2 : Filter.Tendsto (fun t => 1 - Real.exp (-2 * θ * t)) Filter.atTop (nhds (1 - 0)) :=
    Filter.Tendsto.sub tendsto_const_nhds h
  simp only [sub_zero] at h2
  have h3 : Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds ((σ^2 / (2 * θ)) * 1)) :=
    Filter.Tendsto.const_mul _ h2
  simp only [mul_one] at h3
  exact h3

/-- OU process is Gaussian with specific mean and variance -/
theorem ou_is_gaussian {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    IsGaussian μ (fun ω => X.process t ω - X.process 0 ω * Real.exp (-θ * t))
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))) :=
  X.gaussian_conditional t ht

/-- The variance is always non-negative and bounded by σ²/(2θ) -/
theorem ou_variance_bounds {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    0 ≤ (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ∧
    (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ≤ σ^2 / (2 * θ) := by
  constructor
  · -- Non-negativity: (σ²/2θ) ≥ 0 and (1 - e^{-2θt}) ≥ 0 for t ≥ 0
    apply mul_nonneg
    · apply div_nonneg (sq_nonneg σ)
      linarith
    · have hexp : Real.exp (-2 * θ * t) ≤ 1 := by
        rw [Real.exp_le_one_iff]
        have : 0 ≤ 2 * θ * t := by nlinarith
        linarith
      linarith
  · -- Upper bound: (1 - e^{-2θt}) ≤ 1
    have hexp_pos : 0 < Real.exp (-2 * θ * t) := Real.exp_pos _
    have h1 : 1 - Real.exp (-2 * θ * t) ≤ 1 := by linarith
    have hcoef : 0 ≤ σ^2 / (2 * θ) := by
      apply div_nonneg (sq_nonneg σ)
      linarith
    calc (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))
        ≤ (σ^2 / (2 * θ)) * 1 := by apply mul_le_mul_of_nonneg_left h1 hcoef
      _ = σ^2 / (2 * θ) := mul_one _

end SPDE
