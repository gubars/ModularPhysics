/-
Copyright (c) 2025 ModularPhysics. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import ModularPhysics.RigorousQFT.SPDE.Basic
import ModularPhysics.RigorousQFT.SPDE.Probability.Basic
import Mathlib.Probability.Independence.Basic

/-!
# Brownian Motion and Wiener Processes

This file defines Brownian motion, cylindrical Wiener processes,
and related constructions for SPDEs.

## Main Definitions

* `BrownianMotion` - Standard Brownian motion / Wiener process
* `CylindricalWienerProcess` - Cylindrical Wiener process on a Hilbert space
* `QWienerProcess` - Q-Wiener process with covariance operator Q

## Mathematical Properties

A standard Brownian motion W_t is characterized by:
1. W_0 = 0 a.s.
2. Continuous sample paths a.s.
3. Independent increments: W_t - W_s is independent of F_s for s ≤ t
4. Gaussian increments: W_t - W_s ~ N(0, t-s) for s ≤ t

## References

* Karatzas, Shreve, "Brownian Motion and Stochastic Calculus"
* Da Prato, Zabczyk, "Stochastic Equations in Infinite Dimensions"
-/

namespace SPDE

open MeasureTheory ProbabilityTheory SPDE.Probability

variable {Ω : Type*} [MeasurableSpace Ω]

/-! ## Brownian Motion -/

-- Use SPDE.Probability.IsGaussian for Gaussian distribution characterization

/-- Standard Brownian motion (Wiener process).

    A process W : [0, ∞) × Ω → ℝ satisfying:
    1. W_0 = 0 a.s.
    2. Continuous sample paths a.s.
    3. Independent increments: for 0 ≤ s < t, the increment W_t - W_s is
       independent of the σ-algebra F_s = σ(W_u : u ≤ s)
    4. Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t

    These four properties uniquely characterize Brownian motion (in distribution).
    Note: Stationarity follows from (4): the distribution of W_t - W_s depends
    only on t - s, not on s or t individually. -/
structure BrownianMotion (Ω : Type*) [MeasurableSpace Ω] (μ : Measure Ω) where
  /-- The underlying filtration (natural filtration of W) -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F ℝ
  /-- Initial condition: W_0 = 0 a.s. -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths a.s. -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)

  /-- Independent increments: W_t - W_s is independent of F_s for s ≤ t.
      Expressed as: the σ-algebra generated by the increment is independent
      of F_s in the sense of Mathlib's `Indep`. -/
  independent_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    Indep (F.σ_algebra s) (MeasurableSpace.comap (fun ω => toAdapted.process t ω - toAdapted.process s ω) inferInstance) μ

  /-- Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t.
      This implies both zero mean and variance = t - s. -/
  gaussian_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    Probability.IsGaussian (fun ω => toAdapted.process t ω - toAdapted.process s ω) μ 0 (t - s)

/-- Alternative characterization using the product measure formulation of independence:
    For disjoint intervals, the increments are independent. -/
def BrownianMotion.disjoint_independent {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) :
    ∀ s₁ t₁ s₂ t₂ : ℝ, 0 ≤ s₁ → s₁ ≤ t₁ → t₁ ≤ s₂ → s₂ ≤ t₂ →
    IndepFun (fun ω => W.toAdapted.process t₁ ω - W.toAdapted.process s₁ ω)
             (fun ω => W.toAdapted.process t₂ ω - W.toAdapted.process s₂ ω) μ := by
  intro s₁ t₁ s₂ t₂ hs₁ ht₁ hs₂ ht₂
  -- The second increment is independent of F_{s₂} ⊇ F_{t₁} ⊇ σ(first increment)
  sorry

/-- Stationary increments: W_{t+h} - W_t has the same distribution as W_h - W_0 = W_h.
    This follows from the Gaussian characterization. -/
theorem BrownianMotion.stationary_increments {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) :
    ∀ s t : ℝ, 0 ≤ s → 0 ≤ t →
    Measure.map (fun ω => W.toAdapted.process (s + t) ω - W.toAdapted.process s ω) μ =
    Measure.map (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ := by
  intro s t hs ht
  -- Both increments are N(0, t) by gaussian_increments, so they have the same distribution
  sorry

/-- Zero mean of increments (follows from Gaussian with mean 0) -/
theorem BrownianMotion.increment_mean_zero {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω) ∂μ = 0 :=
  (W.gaussian_increments s t hs hst).mean_eq

/-- Variance of increments (follows from Gaussian with variance t-s) -/
theorem BrownianMotion.increment_variance {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω)^2 ∂μ = t - s := by
  have h := (W.gaussian_increments s t hs hst).variance_eq
  simp only [sub_zero] at h
  exact h

namespace BrownianMotion

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}

/-- The process underlying Brownian motion -/
def process (W : BrownianMotion Ω μ) : ℝ → Ω → ℝ := W.toAdapted.process

/-- Brownian motion is a martingale.

    The martingale property E[W_t | F_s] = W_s follows from:
    1. W_t = W_s + (W_t - W_s)
    2. W_s is F_s-measurable
    3. W_t - W_s is independent of F_s (by independent_increments)
    4. E[W_t - W_s] = 0 (by gaussian_increments with mean 0)
    Therefore E[W_t | F_s] = W_s + E[W_t - W_s | F_s] = W_s + E[W_t - W_s] = W_s + 0 = W_s

    **Note**: The current BrownianMotion structure is indexed by ℝ but only defines
    properties (gaussian_increments, independent_increments) for 0 ≤ s ≤ t.
    A cleaner approach would be to index by ℝ≥0, but this would require refactoring
    the Filtration and related structures. For now, we handle the t < 0 case with sorry.

    **Required infrastructure**:
    - Independence implies integral factorization: for A ∈ F_s and X independent of F_s,
      ∫_A X dμ = μ(A) * ∫ X dμ. This is in Mathlib as `IndepFun.integral_mul_eq_mul_integral`
      but we need to connect `Indep` (σ-algebra independence) to this. -/
theorem is_martingale (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∃ M : Martingale W.F μ ℝ, M.process = W.process := by
  use {
    toAdapted := W.toAdapted
    integrable := fun t => by
      by_cases ht : t ≥ 0
      · have hgauss := W.gaussian_increments 0 t (le_refl 0) ht
        have hincr : Integrable (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ :=
          hgauss.integrable
        have heq : (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) =ᶠ[ae μ]
                   W.toAdapted.process t := by
          filter_upwards [W.initial] with ω h0; simp [h0]
        exact hincr.congr heq
      · -- BrownianMotion properties only defined for t ≥ 0
        -- TODO: Either extend definition or restrict time index to ℝ≥0
        sorry
    martingale_property := fun s t hst A hA => by
      by_cases hs : s ≥ 0
      · -- Key: ∫_A W_t dμ = ∫_A W_s dμ, equivalently ∫_A (W_t - W_s) dμ = 0
        have hgauss := W.gaussian_increments s t hs hst
        have hmean : ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω) ∂μ = 0 :=
          hgauss.mean_eq
        have hindep := W.independent_increments s t hs hst
        -- hindep : Indep (F.σ_algebra s) (comap increment) μ
        -- We need the symmetric: Indep (comap increment) (F.σ_algebra s) μ
        have hindep_symm := hindep.symm
        -- Define the increment function
        let incr := fun ω => W.toAdapted.process t ω - W.toAdapted.process s ω
        -- Show the increment integral over A is zero
        have hm₂ : W.F.σ_algebra s ≤ ‹MeasurableSpace Ω› := W.F.le_ambient s
        -- SigmaFinite instance: finite measure trim is sigma-finite
        haveI : SigmaFinite (μ.trim hm₂) := inferInstance
        -- The increment is strongly measurable w.r.t. its comap σ-algebra
        have hincr_sm : StronglyMeasurable[MeasurableSpace.comap incr inferInstance] incr :=
          _root_.SPDE.Probability.stronglyMeasurable_comap_self incr
        -- The comap σ-algebra is ≤ ambient
        have hm₁ : MeasurableSpace.comap incr inferInstance ≤ ‹MeasurableSpace Ω› := by
          apply MeasurableSpace.comap_le_iff_le_map.mpr
          intro s' hs'
          -- incr = W_t - W_s is measurable since W_t and W_s are measurable
          have hWt : Measurable (W.toAdapted.process t) :=
            (W.toAdapted.adapted t).mono (W.F.le_ambient t) le_rfl
          have hWs : Measurable (W.toAdapted.process s) :=
            (W.toAdapted.adapted s).mono (W.F.le_ambient s) le_rfl
          exact (hWt.sub hWs) hs'
        have hincr_int := hgauss.integrable
        -- Apply the key lemma: ∫_A incr dμ = 0
        have hzero : ∫ ω in A, incr ω ∂μ = 0 :=
          Probability.setIntegral_eq_zero_of_indep_zero_mean hm₁ hm₂ hincr_sm hincr_int hindep_symm hmean A hA
        -- Now show ∫_A W_t = ∫_A W_s
        have hWt_int : Integrable (W.toAdapted.process t) μ := by
          have h0 := W.gaussian_increments 0 t (le_refl 0) (le_trans hs hst)
          have hincr0 : Integrable (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ := h0.integrable
          have heq : (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) =ᶠ[ae μ] W.toAdapted.process t := by
            filter_upwards [W.initial] with ω h0'; simp [h0']
          exact hincr0.congr heq
        have hWs_int : Integrable (W.toAdapted.process s) μ := by
          have h0 := W.gaussian_increments 0 s (le_refl 0) hs
          have hincr0 : Integrable (fun ω => W.toAdapted.process s ω - W.toAdapted.process 0 ω) μ := h0.integrable
          have heq : (fun ω => W.toAdapted.process s ω - W.toAdapted.process 0 ω) =ᶠ[ae μ] W.toAdapted.process s := by
            filter_upwards [W.initial] with ω h0'; simp [h0']
          exact hincr0.congr heq
        -- ∫_A W_t = ∫_A (W_s + incr) = ∫_A W_s + ∫_A incr = ∫_A W_s + 0
        have heq' : ∀ ω, W.toAdapted.process t ω = W.toAdapted.process s ω + incr ω := by
          intro ω; simp only [incr]; ring
        -- Use that W_t = W_s + incr implies ∫_A W_t = ∫_A W_s + ∫_A incr
        have hsum : ∫ ω in A, W.toAdapted.process t ω ∂μ =
                    ∫ ω in A, W.toAdapted.process s ω ∂μ + ∫ ω in A, incr ω ∂μ := by
          have hfun_eq : (fun ω => W.toAdapted.process t ω) =
                         (fun ω => W.toAdapted.process s ω + incr ω) := funext heq'
          rw [hfun_eq]
          exact integral_add hWs_int.integrableOn hincr_int.integrableOn
        rw [hsum, hzero, add_zero]
      · sorry -- s < 0 case: BrownianMotion properties only defined for s ≥ 0
  }
  rfl

/-- The quadratic variation of Brownian motion is t -/
theorem quadratic_variation (W : BrownianMotion Ω μ) :
    ∃ qv : QuadraticVariation W.F,
      qv.process = W.process ∧
      (∀ t : ℝ, ∀ᵐ ω ∂μ, qv.variation t ω = t) := by
  sorry

/-- Brownian scaling: if W_t is a BM, then c^{-1/2} W_{ct} is also a BM -/
theorem scaling (W : BrownianMotion Ω μ) (c : ℝ) (hc : 0 < c) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = c^(-(1/2 : ℝ)) * W.process (c * t) ω := by
  sorry

/-- Reflection principle: -W is also a Brownian motion -/
theorem reflection (W : BrownianMotion Ω μ) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = -W.process t ω := by
  sorry

/-- Time inversion: tW_{1/t} is a Brownian motion (for t > 0) -/
theorem time_inversion (W : BrownianMotion Ω μ) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, 0 < t → ∀ᵐ ω ∂μ, W'.process t ω = t * W.process (1/t) ω := by
  sorry

end BrownianMotion

/-! ## Multidimensional Brownian Motion -/

/-- d-dimensional Brownian motion -/
structure BrownianMotionD (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (Fin d → ℝ)
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)
  /-- Covariance: E[W_t^i W_s^j] = (t ∧ s) δ_{ij} -/
  covariance : ∀ i j : Fin d, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω i) * (toAdapted.process s ω j) ∂μ =
      if i = j then min t s else 0

/-! ## Cylindrical Wiener Process -/

/-- A cylindrical Wiener process on a Hilbert space H.
    This is a generalization of Brownian motion to infinite dimensions. -/
structure CylindricalWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [MeasurableSpace (H →L[ℝ] ℝ)] where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (H →L[ℝ] ℝ)
  /-- Isometry property: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨h₁, h₂⟩ -/
  isometry : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω h₁) * (toAdapted.process s ω h₂) ∂μ =
      min t s * @inner ℝ H _ h₁ h₂

namespace CylindricalWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [MeasurableSpace (H →L[ℝ] ℝ)]

/-- The cylindrical Wiener process evaluated on h ∈ H gives a real-valued process -/
def eval (W : CylindricalWienerProcess Ω μ H) (h : H) : ℝ → Ω → ℝ :=
  fun t ω => W.toAdapted.process t ω h

/-- Evaluation on a unit vector gives a standard Brownian motion -/
theorem eval_unit_is_brownian (W : CylindricalWienerProcess Ω μ H) (h : H) (hh : ‖h‖ = 1) :
    ∃ B : BrownianMotion Ω μ, ∀ t : ℝ, ∀ᵐ ω ∂μ, B.process t ω = W.eval h t ω := by
  sorry

end CylindricalWienerProcess

/-! ## Q-Wiener Process -/

/-- A trace-class operator on a separable Hilbert space H.

    A bounded linear operator Q : H → H is trace-class if:
    1. Q is self-adjoint: ⟨Qx, y⟩ = ⟨x, Qy⟩
    2. Q is non-negative: ⟨Qx, x⟩ ≥ 0
    3. The trace Tr(Q) = Σᵢ ⟨Qeᵢ, eᵢ⟩ is finite for any ONB {eᵢ}

    For such operators, there exists an orthonormal basis of eigenvectors
    with non-negative eigenvalues λᵢ such that Σᵢ λᵢ < ∞. -/
structure TraceClassOperator (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] where
  /-- The underlying continuous linear map -/
  toLinearMap : H →L[ℝ] H
  /-- Self-adjoint: ⟨Qh₁, h₂⟩ = ⟨h₁, Qh₂⟩ -/
  self_adjoint : ∀ h₁ h₂ : H, @inner ℝ H _ (toLinearMap h₁) h₂ = @inner ℝ H _ h₁ (toLinearMap h₂)
  /-- Non-negative: ⟨Qh, h⟩ ≥ 0 -/
  nonneg : ∀ h : H, @inner ℝ H _ (toLinearMap h) h ≥ 0
  /-- Trace is finite: Σᵢ ⟨Qeᵢ, eᵢ⟩ < ∞ for any orthonormal basis {eᵢ}.
      We express this via the eigenvalue characterization:
      there exist eigenvalues λᵢ ≥ 0 with Σᵢ λᵢ < ∞. -/
  eigenvalues : ℕ → ℝ
  eigenvalues_nonneg : ∀ i, eigenvalues i ≥ 0
  eigenvalues_summable : Summable eigenvalues

/-- The trace is the sum of eigenvalues -/
noncomputable def TraceClassOperator.trace {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] (Q : TraceClassOperator H) : ℝ := ∑' i, Q.eigenvalues i

namespace TraceClassOperator

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H]

/-- The trace is non-negative -/
theorem trace_nonneg (Q : TraceClassOperator H) : Q.trace ≥ 0 := by
  apply tsum_nonneg
  exact Q.eigenvalues_nonneg

/-- Zero operator is trace-class with trace 0 -/
def zero : TraceClassOperator H where
  toLinearMap := 0
  self_adjoint := fun _ _ => by simp
  nonneg := fun _ => by simp
  eigenvalues := fun _ => 0
  eigenvalues_nonneg := fun _ => le_refl 0
  eigenvalues_summable := summable_zero

end TraceClassOperator

/-- A Q-Wiener process with covariance operator Q.
    More regular than cylindrical Wiener process when Tr(Q) < ∞. -/
structure QWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] [MeasurableSpace H] (Q : TraceClassOperator H) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F H
  /-- Covariance: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨Qh₁, h₂⟩ -/
  covariance : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, @inner ℝ H _ (toAdapted.process t ω) h₁ * @inner ℝ H _ (toAdapted.process s ω) h₂ ∂μ =
      min t s * @inner ℝ H _ (Q.toLinearMap h₁) h₂

namespace QWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H] [MeasurableSpace H]
variable {Q : TraceClassOperator H}

/-- Q-Wiener process has continuous paths in H -/
theorem continuous_paths (W : QWienerProcess Ω μ H Q) :
    ∀ᵐ ω ∂μ, Continuous (fun t => W.toAdapted.process t ω) := by
  sorry

/-- The covariance operator determines the regularity -/
theorem regularity_from_trace (W : QWienerProcess Ω μ H Q) :
    ∀ t : ℝ, 0 ≤ t → ∃ (bound : ℝ), ∫ ω, ‖W.toAdapted.process t ω‖^2 ∂μ ≤ bound := by
  sorry

end QWienerProcess

/-! ## Space-Time White Noise -/

/-- Space-time white noise on a domain D ⊆ ℝ^d -/
structure SpaceTimeWhiteNoise (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) (D : Set (Fin d → ℝ)) [MeasurableSpace D] (ν : Measure D) where
  /-- The distribution W(ϕ) for test function ϕ -/
  eval : (D → ℝ) → (Ω → ℝ)
  /-- Linearity -/
  linear : ∀ a b : ℝ, ∀ ϕ ψ : D → ℝ,
    eval (fun x => a * ϕ x + b * ψ x) = fun ω => a * eval ϕ ω + b * eval ψ ω
  /-- Isometry: E[W(ϕ)W(ψ)] = ⟨ϕ, ψ⟩_{L²} -/
  isometry : ∀ ϕ ψ : D → ℝ, ∫ ω, eval ϕ ω * eval ψ ω ∂μ = ∫ x, ϕ x * ψ x ∂ν

/-! ## Lévy's Characterization -/

/-- Lévy's characterization: a continuous local martingale with
    quadratic variation ⟨M⟩_t = t is a Brownian motion. -/
theorem levy_characterization {Ω : Type*} [MeasurableSpace Ω]
    {F : Filtration Ω ℝ} {μ : Measure Ω} [IsProbabilityMeasure μ]
    (M : LocalMartingale F μ ℝ)
    (continuous : ∀ᵐ ω ∂μ, Continuous (fun t => M.process t ω))
    (initial : ∀ᵐ ω ∂μ, M.process 0 ω = 0)
    (qv : QuadraticVariation F)
    (hqv_process : qv.process = M.process)
    (hqv_is_t : ∀ t : ℝ, 0 ≤ t → ∀ᵐ ω ∂μ, qv.variation t ω = t) :
    ∃ W : BrownianMotion Ω μ, W.process = M.process := by
  sorry

/-! ## Brownian Bridge -/

/-- Brownian bridge from 0 to a at time T -/
structure BrownianBridge (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (T : ℝ) (hT : 0 < T) (a : ℝ) where
  /-- The process on [0, T] -/
  process : Set.Icc 0 T → Ω → ℝ
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, process ⟨0, by constructor <;> linarith⟩ ω = 0
  /-- Terminal condition -/
  terminal : ∀ᵐ ω ∂μ, process ⟨T, by constructor <;> linarith⟩ ω = a
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => process t ω)
  /-- Covariance: E[B_s B_t] = s(T-t)/T for s ≤ t -/
  covariance : ∀ (s t : Set.Icc 0 T), s.val ≤ t.val →
    ∫ ω, process s ω * process t ω ∂μ = s.val * (T - t.val) / T

/-! ## Ornstein-Uhlenbeck Process -/

/-- Ornstein-Uhlenbeck process: dX_t = -θ X_t dt + σ dW_t

    The explicit solution is:
    X_t = X_0 e^{-θt} + σ ∫₀ᵗ e^{-θ(t-s)} dW_s

    Key properties:
    1. Conditional mean: E[X_t | X_0] = X_0 e^{-θt}  (mean-reversion)
    2. Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt})
    3. Stationary distribution: N(0, σ²/2θ)
    4. Gaussian process (all finite-dimensional distributions are Gaussian) -/
structure OrnsteinUhlenbeck (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (θ σ : ℝ) (hθ : 0 < θ) (hσ : 0 < σ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The process -/
  process : ℝ → Ω → ℝ
  /-- Driven by Brownian motion -/
  driving_BM : BrownianMotion Ω μ
  /-- Adapted to the filtration -/
  adapted : ∀ t : ℝ, @Measurable Ω ℝ (F.σ_algebra t) _ (process t)
  /-- Mean-reverting property: E[X_t | F_0] = X_0 e^{-θt}
      Expressed via conditional expectation: for all F_0-measurable sets A,
      ∫_A X_t dμ = ∫_A X_0 e^{-θt} dμ -/
  mean_reversion : ∀ t : ℝ, 0 ≤ t →
    ∀ A : Set Ω, @MeasurableSet Ω (F.σ_algebra 0) A →
    ∫ ω in A, process t ω ∂μ = ∫ ω in A, process 0 ω * Real.exp (-θ * t) ∂μ
  /-- Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt})
      The unconditional variance of the centered process equals this value. -/
  conditional_variance : ∀ t : ℝ, 0 ≤ t →
    ∫ ω, (process t ω - process 0 ω * Real.exp (-θ * t))^2 ∂μ =
      (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))
  /-- X_t is Gaussian given X_0 -/
  gaussian_conditional : ∀ t : ℝ, 0 ≤ t →
    Probability.IsGaussian (fun ω => process t ω - process 0 ω * Real.exp (-θ * t)) μ
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))

/-- In the stationary regime (t → ∞), Var(X_t) → σ²/(2θ) -/
theorem ou_stationary_variance {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) :
    Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds (σ^2 / (2 * θ))) := by
  have h : Filter.Tendsto (fun t => Real.exp (-2 * θ * t)) Filter.atTop (nhds 0) := by
    have hcoef : -2 * θ < 0 := by linarith
    have hmul : Filter.Tendsto (fun t => -2 * θ * t) Filter.atTop Filter.atBot :=
      (Filter.tendsto_const_mul_atBot_of_neg hcoef).mpr Filter.tendsto_id
    exact Real.tendsto_exp_atBot.comp hmul
  have h2 : Filter.Tendsto (fun t => 1 - Real.exp (-2 * θ * t)) Filter.atTop (nhds (1 - 0)) :=
    Filter.Tendsto.sub tendsto_const_nhds h
  simp only [sub_zero] at h2
  have h3 : Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds ((σ^2 / (2 * θ)) * 1)) :=
    Filter.Tendsto.const_mul _ h2
  simp only [mul_one] at h3
  exact h3

/-- OU process is Gaussian with specific mean and variance -/
theorem ou_is_gaussian {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    Probability.IsGaussian (fun ω => X.process t ω - X.process 0 ω * Real.exp (-θ * t)) μ
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))) :=
  X.gaussian_conditional t ht

/-- The variance is always non-negative and bounded by σ²/(2θ) -/
theorem ou_variance_bounds {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    0 ≤ (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ∧
    (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ≤ σ^2 / (2 * θ) := by
  constructor
  · -- Non-negativity: (σ²/2θ) ≥ 0 and (1 - e^{-2θt}) ≥ 0 for t ≥ 0
    apply mul_nonneg
    · apply div_nonneg (sq_nonneg σ)
      linarith
    · have hexp : Real.exp (-2 * θ * t) ≤ 1 := by
        rw [Real.exp_le_one_iff]
        have : 0 ≤ 2 * θ * t := by nlinarith
        linarith
      linarith
  · -- Upper bound: (1 - e^{-2θt}) ≤ 1
    have hexp_pos : 0 < Real.exp (-2 * θ * t) := Real.exp_pos _
    have h1 : 1 - Real.exp (-2 * θ * t) ≤ 1 := by linarith
    have hcoef : 0 ≤ σ^2 / (2 * θ) := by
      apply div_nonneg (sq_nonneg σ)
      linarith
    calc (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))
        ≤ (σ^2 / (2 * θ)) * 1 := by apply mul_le_mul_of_nonneg_left h1 hcoef
      _ = σ^2 / (2 * θ) := mul_one _

end SPDE
